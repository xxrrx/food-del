'use strict';

var chunkJGUV45TP_cjs = require('./chunk-JGUV45TP.cjs');
var chunkUOEGPC4B_cjs = require('./chunk-UOEGPC4B.cjs');
var crypto2 = require('crypto');
var dayjs = require('dayjs');
var timezone = require('dayjs/plugin/timezone');
var utc = require('dayjs/plugin/utc');
var fs = require('fs');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var crypto2__default = /*#__PURE__*/_interopDefault(crypto2);
var dayjs__default = /*#__PURE__*/_interopDefault(dayjs);
var timezone__default = /*#__PURE__*/_interopDefault(timezone);
var utc__default = /*#__PURE__*/_interopDefault(utc);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);

dayjs__default.default.extend(utc__default.default);
dayjs__default.default.extend(timezone__default.default);
function getDateInGMT7(date) {
  const inputDate = date ?? /* @__PURE__ */ new Date();
  const utcDate = dayjs__default.default.utc(inputDate);
  return new Date(utcDate.add(7, "hour").valueOf());
}
chunkUOEGPC4B_cjs.__name(getDateInGMT7, "getDateInGMT7");
function dateFormat(date, format = "yyyyMMddHHmmss") {
  const pad = /* @__PURE__ */ chunkUOEGPC4B_cjs.__name((n) => (n < 10 ? `0${n}` : n).toString(), "pad");
  const year = date.getFullYear();
  const month = pad(date.getMonth() + 1);
  const day = pad(date.getDate());
  const hour = pad(date.getHours());
  const minute = pad(date.getMinutes());
  const second = pad(date.getSeconds());
  return Number(
    format.replace("yyyy", year.toString()).replace("MM", month).replace("dd", day).replace("HH", hour).replace("mm", minute).replace("ss", second)
  );
}
chunkUOEGPC4B_cjs.__name(dateFormat, "dateFormat");
function parseDate(dateNumber, tz = "local") {
  const dateString = dateNumber.toString();
  const _parseInt = Number.parseInt;
  const year = _parseInt(dateString.slice(0, 4));
  const month = _parseInt(dateString.slice(4, 6)) - 1;
  const day = _parseInt(dateString.slice(6, 8));
  const hour = _parseInt(dateString.slice(8, 10));
  const minute = _parseInt(dateString.slice(10, 12));
  const second = _parseInt(dateString.slice(12, 14));
  const formattedDate = `${year}-${String(month + 1).padStart(2, "0")}-${String(day).padStart(2, "0")}T${String(hour).padStart(2, "0")}:${String(minute).padStart(2, "0")}:${String(second).padStart(2, "0")}`;
  switch (tz) {
    case "utc": {
      return dayjs__default.default.utc(formattedDate).toDate();
    }
    case "gmt7": {
      const localDate = new Date(year, month, day, hour, minute, second);
      const utcTime = dayjs__default.default.utc(localDate);
      return utcTime.add(7, "hour").toDate();
    }
    // biome-ignore lint/complexity/noUselessSwitchCase: still good to readable
    case "local":
    default:
      return new Date(year, month, day, hour, minute, second);
  }
}
chunkUOEGPC4B_cjs.__name(parseDate, "parseDate");
function isValidVnpayDateFormat(date) {
  const dateString = date.toString();
  const regex = /^\d{4}(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])([01][0-9]|2[0-3])[0-5][0-9][0-5][0-9]$/;
  return regex.test(dateString);
}
chunkUOEGPC4B_cjs.__name(isValidVnpayDateFormat, "isValidVnpayDateFormat");
function generateRandomString(length, options) {
  let result = "";
  let characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  if (options?.onlyNumber) {
    characters = "0123456789";
  }
  const charactersLength = characters.length;
  for (let i = 0; i < length; i++) {
    result += `${characters[Math.random() * charactersLength | 0]}`;
  }
  return result;
}
chunkUOEGPC4B_cjs.__name(generateRandomString, "generateRandomString");
function getResponseByStatusCode(responseCode = "", locale = "vn" /* VN */, responseMap = chunkJGUV45TP_cjs.RESPONSE_MAP) {
  const respondText = responseMap.get(responseCode) ?? responseMap.get("default");
  return respondText[locale];
}
chunkUOEGPC4B_cjs.__name(getResponseByStatusCode, "getResponseByStatusCode");
function resolveUrlString(host, path) {
  let trimmedHost = host.trim();
  let trimmedPath = path.trim();
  while (trimmedHost.endsWith("/") || trimmedHost.endsWith("\\")) {
    trimmedHost = trimmedHost.slice(0, -1);
  }
  while (trimmedPath.startsWith("/") || trimmedPath.startsWith("\\")) {
    trimmedPath = trimmedPath.slice(1);
  }
  return `${trimmedHost}/${trimmedPath}`;
}
chunkUOEGPC4B_cjs.__name(resolveUrlString, "resolveUrlString");
function hash(secret, data, algorithm) {
  return crypto2__default.default.createHmac(algorithm, secret).update(data.toString()).digest("hex");
}
chunkUOEGPC4B_cjs.__name(hash, "hash");
function ignoreLogger() {
}
chunkUOEGPC4B_cjs.__name(ignoreLogger, "ignoreLogger");
function consoleLogger(data, symbol = "log") {
  if (typeof console[symbol] === "function") {
    console[symbol](data);
  }
}
chunkUOEGPC4B_cjs.__name(consoleLogger, "consoleLogger");
function fileLogger(data, filePath, errorCallback) {
  const dataString = typeof data === "object" ? JSON.stringify(data) : String(data);
  fs__namespace.appendFile(filePath, `${dataString}
`, (err) => {
    if (err && typeof errorCallback === "function") {
      return errorCallback(err);
    }
    if (err) {
      console.error("Failed to write to file:", err);
      throw err;
    }
  });
}
chunkUOEGPC4B_cjs.__name(fileLogger, "fileLogger");
function buildPaymentUrlSearchParams(data) {
  const params = new URLSearchParams();
  const sortedKeys = Object.keys(data).sort();
  for (const key of sortedKeys) {
    if (data[key] !== void 0 && data[key] !== null && data[key] !== "") {
      params.append(key, String(data[key]));
    }
  }
  return params;
}
chunkUOEGPC4B_cjs.__name(buildPaymentUrlSearchParams, "buildPaymentUrlSearchParams");
function createPaymentUrl({
  config,
  data
}) {
  const paymentEndpoint = config.endpoints?.paymentEndpoint || config.paymentEndpoint;
  const redirectUrl = new URL(resolveUrlString(config.vnpayHost, paymentEndpoint));
  const searchParams = buildPaymentUrlSearchParams(data);
  redirectUrl.search = searchParams.toString();
  return redirectUrl;
}
chunkUOEGPC4B_cjs.__name(createPaymentUrl, "createPaymentUrl");
function calculateSecureHash({
  secureSecret,
  data,
  hashAlgorithm,
  bufferEncode
}) {
  return crypto2__default.default.createHmac(hashAlgorithm, secureSecret).update(Buffer.from(data, bufferEncode)).digest("hex");
}
chunkUOEGPC4B_cjs.__name(calculateSecureHash, "calculateSecureHash");
function verifySecureHash({
  secureSecret,
  data,
  hashAlgorithm,
  receivedHash
}) {
  const calculatedHash = crypto2__default.default.createHmac(hashAlgorithm, secureSecret).update(Buffer.from(data, "utf-8")).digest("hex");
  return calculatedHash === receivedHash;
}
chunkUOEGPC4B_cjs.__name(verifySecureHash, "verifySecureHash");

exports.buildPaymentUrlSearchParams = buildPaymentUrlSearchParams;
exports.calculateSecureHash = calculateSecureHash;
exports.consoleLogger = consoleLogger;
exports.createPaymentUrl = createPaymentUrl;
exports.dateFormat = dateFormat;
exports.fileLogger = fileLogger;
exports.generateRandomString = generateRandomString;
exports.getDateInGMT7 = getDateInGMT7;
exports.getResponseByStatusCode = getResponseByStatusCode;
exports.hash = hash;
exports.ignoreLogger = ignoreLogger;
exports.isValidVnpayDateFormat = isValidVnpayDateFormat;
exports.parseDate = parseDate;
exports.resolveUrlString = resolveUrlString;
exports.verifySecureHash = verifySecureHash;
//# sourceMappingURL=chunk-2VMSAU7V.cjs.map
//# sourceMappingURL=chunk-2VMSAU7V.cjs.map